# æœ€çŸ­è·¯é—®é¢˜ Shortest Path Problem

[TOC]

## å„ç§æœ€çŸ­è·¯å¾„ç®—æ³•çš„æ¯”è¾ƒ

[æœ€çŸ­è·¯å¾„ç®—æ³•å¯¹æ¯”æ¯”è¾ƒ](https://blog.csdn.net/yuewenyao/article/details/81023035)

|                      | Floyd-Warshall       | Dijkstra             | Bellman-ford       | SPFA            |
| -------------------- | -------------------- | -------------------- | ------------------ | ------------------ |
| ç©ºé—´å¤æ‚åº¦ | O(nÂ²) | O(m) | O(m) | O(m) |
| æ—¶é—´å¤æ‚åº¦           | O(nÂ³)                | O((m+n)logn) | O(nm)            | O(km)(k<<n)      |
| é€‚ç”¨ | ä»»æ„ä¸¤ç‚¹é—´æœ€çŸ­è·¯å¾„ | å•æºæœ€çŸ­è·¯å¾„ | å•æºæœ€çŸ­è·¯å¾„ | å•æºæœ€çŸ­è·¯å¾„ |
| å­˜åœ¨è´Ÿæƒè¾¹              | âœ…               | ä¸èƒ½         | âœ…              | å¯ä»¥               |
| å­˜åœ¨è´Ÿæƒå›è·¯ | ä¸èƒ½            | ä¸èƒ½              | ä¸èƒ½          | å¯ä»¥               |
| åˆ¤æ–­æ˜¯å¦å­˜åœ¨è´Ÿæƒå›è·¯ | ä¸èƒ½                 | ä¸èƒ½                 | âœ…              | å¯ä»¥               |

> Dijkstraç®—æ³•ç”¨æ•°ç»„æ¥å­˜å‚¨æ‰€æœ‰æœªè®¿é—®é¡¶ç‚¹æ—¶é—´å¤æ‚åº¦ä¸ºO(nÂ²)ï¼Œç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–åæ—¶é—´å¤æ‚åº¦ä¸ºO((m+n)logn)ã€‚

ğŸ™‹â€é¡¶ç‚¹æ•° = nï¼Œè¾¹æ•° = m

## Floyd-Warshallç®—æ³•

æ±‚è§£ä»»æ„ä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯å¾„ã€‚æ—¶é—´å¤æ‚åº¦ O(nÂ³)ã€‚

```java
for(int k = 0; k < n; k++){
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j ++){
            if(dist[i][j] > dist[i][k] + dist[k][j])
                dist[i][j] = dist[i][k] + dist[k][j];
        }
    }
}
```

## Dijkstraç®—æ³•

åŸºäºæ•°ç»„çš„Dijkstra's Algorithmæ—¶é—´å¤æ‚åº¦æ˜¯O(nÂ²)ï¼ŒåŸºäºä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–åçš„Dijkstra's Algorithmæ—¶é—´å¤æ‚åº¦æ˜¯  O((m+n)logn)ã€‚

[åšå®¢å›­](https://www.cnblogs.com/wtyuan/p/12071021.html)ï¼š[æ—¶é—´å¤æ‚åº¦çš„è¯´æ˜](https://www.cnblogs.com/wtyuan/p/12071021.html)

[CSDN](https://blog.csdn.net/tabris919/article/details/108212479)

[å›¾è§£](https://blog.csdn.net/yalishadaa/article/details/55827681)

<img src="../../Images/Dijkstra's Algorithm + priority queue.jpg" alt="Dijkstraä¼˜å…ˆé˜Ÿåˆ—å®ç°ç®—æ³•ä¼ªä»£ç " style="zoom:80%;" />

> Javaè‡ªå¸¦çš„PriorityQueueä¸å…·å¤‡ä¿®æ”¹keyçš„åŠŸèƒ½ï¼Œéœ€è¦è‡ªè¡Œå®ç°ã€‚
>
> ä¼˜å…ˆé˜Ÿåˆ—å¯åŸºäºbinary heap or fibonacci heap å®ç°

```c
void DijkstraPriorityQueue() {
	min_heap_insert(element(n, 0));
	distance[n] = 0;
	for (int i = 1; i < n; i++)//å°†æ‰€æœ‰èŠ‚ç‚¹éƒ½æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—ä¸­
		min_heap_insert(element(i, 0x3f3f3f3f));
	for (int i = 1; i <= n; i++) {//æ¯æ¬¡æŠŠä¸€ä¸ªèŠ‚ç‚¹ä»ä¼˜å…ˆé˜Ÿåˆ—ä¸­å–å‡ºåŠ å…¥åˆ°Sä¸­ï¼Œå¤–å±‚å¾ªç¯næ¬¡
		element front_elem = heap_extract_min();
		int u = front_elem.number;
		explored[u] = 1;
		distance[u] = front_elem.key;
		for (int j = head[u]; j >= 0; j = e[j].next) {//éå†uå‡ºå‘çš„æ‰€æœ‰è¾¹
			int v = e[j].v;
			if (explored[v])
				continue;
			if (A[position[v]].key > distance[u] + e[j].length)
				heap_decrease_key(position[v], distance[u] + e[j].length);
		}
	}
}
```






## Bellman-Fordç®—æ³•

[æœ€çŸ­è·¯å¾„(Bellman-Fordç®—æ³•)](https://www.jianshu.com/p/b876fe9b2338)

æ±‚å•æºæœ€çŸ­è·¯ï¼Œå¯ä»¥åˆ¤æ–­æœ‰æ— è´Ÿæƒå›è·¯ï¼ˆè‹¥æœ‰ï¼Œåˆ™ä¸å­˜åœ¨æœ€çŸ­è·¯ï¼‰ï¼Œæ—¶æ•ˆæ€§è¾ƒå¥½ï¼Œæ—¶é—´å¤æ‚åº¦O(nm)

**åŸºæœ¬æ€æƒ³**

step1:åˆå§‹åŒ–dist(i),é™¤äº†åˆå§‹ç‚¹çš„å€¼ä¸º0ï¼Œå…¶ä½™éƒ½ä¸ºinfinitï¼ˆè¡¨ç¤ºæ— ç©·å¤§ï¼Œä¸å¯åˆ°è¾¾ï¼‰,predè¡¨ç¤ºç»è¿‡çš„å‰ä¸€ä¸ªé¡¶ç‚¹
step2:æ‰§è¡Œn-1ï¼ˆnç­‰äºå›¾ä¸­ç‚¹çš„ä¸ªæ•°ï¼‰æ¬¡æ¾å¼›è®¡ç®—ï¼šdist(j)=min( dist(i)+weight(i,j),dist(j) )
step3:å†é‡å¤æ“ä½œä¸€æ¬¡ï¼Œå¦‚å›½dist(j) > distdist(i)+weight(i,j)è¡¨ç¤ºé€”ä¸­å­˜åœ¨ä»æºç‚¹å¯è¾¾çš„æƒä¸ºè´Ÿçš„å›è·¯ã€‚
å› ä¸ºï¼Œå¦‚æœå­˜åœ¨ä»æºç‚¹å¯è¾¾çš„æƒä¸ºè´Ÿçš„å›è·¯ï¼Œåˆ™åº”ä¸ºæ— æ³•æ”¶æ•›è€Œå¯¼è‡´ä¸èƒ½æ±‚å‡ºæœ€çŸ­è·¯å¾„ã€‚ 
å› ä¸ºè´Ÿæƒç¯å¯ä»¥æ— é™åˆ¶çš„é™ä½æ€»èŠ±è´¹ï¼Œæ‰€ä»¥å¦‚æœå‘ç°ç¬¬næ¬¡æ“ä½œä»å¯é™ä½èŠ±é”€ï¼Œå°±ä¸€å®šå­˜åœ¨è´Ÿæƒç¯ã€‚

```java
int[] dist=new int[n];
int[] pre=new int[n];
 
public void Bellman_Ford(){
  //åˆå§‹åŒ–
  for(int i=1;i<n-1;i++){
     dist[i]=infinit; //TODO
  }//end for
    
  dist[s]=0 //èµ·å§‹ç‚¹çš„å€¼  
  
  for (int i=1;i<=n-1;i++){
    for(int j=1;j<=edgenum; j++){
      if(dist(i)+weight(i,j) <dist(j) ){
	     dist(j)=dist(i)+weight(i,j);
	     pred(j)=i;
	  }//end if
    }//end for
  }//end for
  
  //
  for(int j=1;j<=edgenum;j++){
     if(dist(i)+weight(i,j)<dist()j )
	    return "æœ‰è´Ÿæƒå›è·¯ï¼Œä¸å­˜åœ¨æœ€çŸ­è·¯å¾„";
  }//end for
  
}//end Bellman_Ford()
```


## SPFA

Bellman-Fordçš„é˜Ÿåˆ—ä¼˜åŒ–ï¼Œæ—¶æ•ˆæ€§ç›¸å¯¹å¥½ï¼Œæ—¶é—´å¤æ‚åº¦O(km)(k<<n)

## DAGç®—æ³•

[POJ 3249-DAGçš„å•æºæœ€çŸ­è·¯å¾„](https://www.cnblogs.com/shuiming/p/7006651.html)

[æœ‰å‘æ— ç¯å›¾(DAG)å•æºæœ€çŸ­è·¯å¾„](https://www.jianshu.com/p/cf1b9fcfe3bf)

æ—¶é—´å¤æ‚åº¦ï¼šæ‹“æ‰‘æ’åºçš„æ—¶é—´ä¸ºO(n+m)ï¼Œåˆå§‹åŒ–çš„æ—¶é—´ä¸ºO(n)ï¼ŒåŒé‡å¾ªç¯ç›¸å½“äºå¯¹æ¯æ¡è¾¹è¿›è¡Œæ¾å¼›ï¼Œæ—¶é—´ä¸ºO(m)ï¼Œæ€»æ—¶é—´ä¸ºO(n+m+n+m)=O(n+m)

å•æºï¼Œæœ‰å‘

```c++
#include <cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int MAXE=1000010;
const int MAXN=100010;
const int INF=0x3f3f3f3f;
struct Node
{
    int to,val,next;
};
Node edge[MAXE];
int head[MAXN];
queue<int> result;
int in[MAXN];
int dis[MAXN];
int cnt;
void addEdge(int u,int v,int val)
{
    edge[cnt].to=v;
    edge[cnt].next=head[u];
    edge[cnt].val=val;
    head[u]=cnt++;
}
void topoSort(int n)
{
    queue<int> zero;
    for(int i=1;i<=n;i++)
    {
        if(in[i]==0) zero.push(i);
    }
    while(!zero.empty())
    {
        int u=zero.front();
        zero.pop();
        result.push(u);
        for(int i=head[u];i!=-1;i=edge[i].next)
        {
            int v=edge[i].to;
            in[v]--;
            if(in[v]==0) zero.push(v);
        }
    }
}
void DAGShortestPath(int st,int n)
{
    topoSort(n);
    memset(dis,INF,sizeof(dis));
    dis[st]=0;
    while(!result.empty())
    {
        int u=result.front();
        result.pop();
        for(int i=head[u];i!=-1;i=edge[i].next)
        {
            int v=edge[i].to;
            if(dis[v]>dis[u]+edge[i].val)
            {
                dis[v]=dis[u]+edge[i].val;
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(dis[i]==INF) printf("INF\n");
        else printf("%d\n",dis[i]);
    }
}
int main()
{
    int n,m,a,b,val,st;
    while(scanf("%d%d",&n,&m)!=EOF)
    {
        scanf("%d",&st);
        memset(head,-1,sizeof(head));
        memset(in,0,sizeof(in));
        cnt=0;
        for(int i=1;i<=m;i++)
        {
            scanf("%d%d%d",&a,&b,&val);
            addEdge(a,b,val);
            in[b]++;
        }
        DAGShortestPath(st,n);
    }
}
```

**æ‹“æ‰‘æ’åº**

[è®²è§£](https://blog.csdn.net/Sensente/article/details/100879709?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase)

```c++
/*
 * ç®—æ³•æè¿°
 * while(å­˜åœ¨å…¥åº¦ä¸º0çš„ç‚¹){
 * 1.é€‰æ‹©ä¸€ä¸ªå…¥åº¦ä¸º0çš„ç‚¹å¹¶å°†å®ƒè¾“å‡º
 * 2.åˆ é™¤å›¾ä¸­ä»é¡¶ç‚¹è¿å‡ºçš„æ‰€æœ‰è¾¹
 * }
 * å¾ªç¯ç»“æŸ
 * if(è¾“å‡ºé¡¶ç‚¹æ•°å°äºå›¾ä¸­çš„é¡¶ç‚¹æ•°) å›¾ä¸­å­˜åœ¨å›è·¯ï¼Œæ— æ³•æ‹“æ‰‘æ’åº
 * else è¾“å‡ºç‚¹å³ä¸ºæ‹“æ‰‘æ’åº
 */
 
 //é“¾å¼å‰å‘æ˜Ÿ
int p[maxn];
int topo() {
    queue<int> q;
    for(int i = 1; i <= N; i++) {
        if(indegree[i] == 0) {
            q.push(i);
        }
    }
    while(!q.empty()) {
        int now = q.front();
        q.pop();
        for(int i = p[now]; ~i; i = e[i].next) {
            int v = e[i].v;
            indegree[v]--;
            if(indegree[v] = 0) {
                q.push(v);
            }
        }
    }
}

```

**é“¾å¼å‰å‘æ˜Ÿ**

[è®²è§£](https://blog.csdn.net/acdreamers/article/details/16902023)

å‰å‘æ˜Ÿæ˜¯ä¸€ç§ç‰¹æ®Šçš„è¾¹é›†æ•°ç»„,æˆ‘ä»¬æŠŠè¾¹é›†æ•°ç»„ä¸­çš„æ¯ä¸€æ¡è¾¹æŒ‰ç…§èµ·ç‚¹ä»å°åˆ°å¤§æ’åº,å¦‚æœèµ·ç‚¹ç›¸åŒå°±æŒ‰ç…§ç»ˆç‚¹ä»å°åˆ°å¤§æ’åº, å¹¶è®°å½•ä¸‹ä»¥æŸä¸ªç‚¹ä¸ºèµ·ç‚¹çš„æ‰€æœ‰è¾¹åœ¨æ•°ç»„ä¸­çš„èµ·å§‹ä½ç½®å’Œå­˜å‚¨é•¿åº¦,é‚£ä¹ˆå‰å‘æ˜Ÿå°±æ„é€ å¥½äº†.

```
head[i]è®°å½•ä»¥iä¸ºè¾¹é›†åœ¨æ•°ç»„ä¸­çš„ç¬¬ä¸€ä¸ªå­˜å‚¨ä½ç½®
len[i]æ¥è®°å½•æ‰€æœ‰ä»¥iä¸ºèµ·ç‚¹çš„è¾¹åœ¨æ•°ç»„ä¸­çš„å­˜å‚¨é•¿åº¦.
```

ä½†æ˜¯åˆ©ç”¨å‰å‘æ˜Ÿä¼šæœ‰æ’åºæ“ä½œ,å¦‚æœç”¨å¿«æ’æ—¶é—´è‡³å°‘ä¸ºO(nlog(n)). å¦‚æœç”¨é“¾å¼å‰å‘æ˜Ÿ,å°±å¯ä»¥é¿å…æ’åº.

æˆ‘ä»¬å»ºç«‹è¾¹ç»“æ„ä½“ä¸º:

```c++
struct Edge {
    int next;
    int to;
    int w;
};

// edge[i].toè¡¨ç¤ºç¬¬iæ¡è¾¹çš„ç»ˆç‚¹
// edge[i].nextè¡¨ç¤ºä¸ç¬¬iæ¡è¾¹åŒèµ·ç‚¹çš„ä¸‹ä¸€æ¡è¾¹çš„å­˜å‚¨ä½ç½®
// edge[i].wä¸ºè¾¹æƒå€¼
```

å¦å¤–è¿˜æœ‰ä¸€ä¸ªæ•°ç»„`head[]`,å®ƒæ˜¯ç”¨æ¥è¡¨ç¤ºä»¥`i`ä¸ºèµ·ç‚¹çš„ç¬¬ä¸€æ¡è¾¹å­˜å‚¨çš„ä½ç½®,å®é™…ä¸Šä½ ä¼šå‘ç°è¿™é‡Œçš„ç¬¬ä¸€æ¡è¾¹å­˜å‚¨çš„ä½ç½®å…¶å®åœ¨ä»¥`i`ä¸ºèµ·ç‚¹çš„æ‰€æœ‰è¾¹çš„æœ€åè¾“å…¥çš„é‚£ä¸ªç¼–å·.(é€†åºéå†) `head[]`æ•°ç»„ä¸€èˆ¬åˆå§‹åŒ–ä¸º-1ã€‚

```c++
void add(int u,int v,int w)
{
    edge[cnt].w = w;
    edge[cnt].to = v;
    edge[cnt].next = head[u];
    head[u] = cnt++;
}
```

æˆ‘ä»¬åœ¨éå†ä»¥uèŠ‚ç‚¹ä¸ºèµ·å§‹ä½ç½®çš„æ‰€æœ‰è¾¹çš„æ—¶å€™æ˜¯è¿™æ ·çš„:

```c++
for(int i=head[u];~i;i=edge[i].next)
```

